import ast
import astunparse
import astpretty
###########################################################
# This is just an exaple used to understand ast parser.
# It is not used in our data collection.
# The ast.parser remove comments and unnecessary white 
# space from source code, after do some preprocessing
# via visitor pattern.
###########################################################
tree = ast.parse("""
# Automatically generated by Pynguin.
import pytest
import Identifier as module_0


def test_case_0():
    identifier_0 = module_0.Identifier()
    str_0 = "H9"
    var_0 = identifier_0.validateIdentifier(str_0)
    assert var_0 is True


@pytest.mark.xfail(strict=True)
def test_case_5():
    str_0 = "e6ic|mE"
    identifier_0 = module_0.Identifier()
    var_0 = identifier_0.validateIdentifier(str_0)
    assert var_0 is False
    str_1 = "f"
    var_1 = identifier_0.validateIdentifier(str_1)
    assert var_1 is True
    #var_0.validateIdentifier(var_1)
""")

# Este método imprime a árvore de parser de modo
# a ser melhor visualizada
astpretty.pprint(tree, indent='  ')

# Por padrão, 
class MyVisitor(ast.NodeVisitor):
    #def generic_visit(self, node):
    #    if (isinstance(node, ast.FunctionDef)):
    #        if (len(node.decorator_list)>0):
    #            print(f'Nodetype: {type(node).__name__:{16}} {node}')
    #            print(node.name)
    #            print(node.body[:-1])
    #    ast.NodeVisitor.generic_visit(self, node)

    def visit_FunctionDef(self, node):
        print(node.name)
        print(f'Nodetype: {type(node).__name__:{16}} {node}')

        if (len(node.decorator_list)>0):
            print("Corpo do método completo")
            print(node.body)
            print("Corpo do método sem o último elemento")
            print(node.body[:-1])
        else:
            print("Método sem decorator_list")

v = MyVisitor()
print('Using NodeVisitor (depth first):')
v.visit(tree)

print(astunparse.dump(tree))

print(ast.unparse(tree))